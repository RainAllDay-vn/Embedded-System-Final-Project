\documentclass[12pt, a4paper]{article}

% GÓI NGÔN NGỮ VÀ FONT
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{helvet} 
\usepackage{color} % Thêm gói màu
\usepackage{xcolor}
\usepackage{tabularx} % Hỗ trợ bảng tự động chỉnh độ rộng cột
\usepackage{booktabs} % Giúp đường kẻ bảng chuyên nghiệp hơn
\usepackage{listings} % For code snippets
\usepackage{float}
\renewcommand{\arraystretch}{1.4} % Tăng khoảng cách giữa các dòng trong bảng

% CODE LISTING STYLE
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                  
    captionpos=b,                     
    keepspaces=true,                  
    numbers=left,                     
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

% GÓI BỐ CỤC VÀ HÌNH ẢNH
\usepackage[margin=1in]{geometry}
\usepackage{graphicx} 
\usepackage[hidelinks]{hyperref} 
\usepackage{booktabs} 
\usepackage{parskip} 
\usepackage{float}
\usepackage{fancyhdr} 
\usepackage{titlesec} 
\usepackage{longtable} % Cho bảng dài qua trang
\usepackage{array}
\usepackage{amsmath}

% TÙY CHỈNH TIÊU ĐỀ SECTION
\titleformat{\section}
  {\normalfont\Large\bfseries\color{blue!60!black}}
  {\thesection}{1em}{}
\titleformat{\subsection}
  {\normalfont\large\bfseries\color{black}}
  {\thesubsection}{1em}{}

% HỘP ĐỂ GIỮ CHỖ HÌNH ẢNH
\newcommand{\imageplaceholder}[2]{
  \begin{figure}[H]
    \centering
    \fbox{
      \parbox[c][#1][c]{0.8\textwidth}{
        \centering
        \vspace{10pt}
        \texttt{#2}
        \vspace{10pt}
      }
    }
    \caption{#2}
  \end{figure}
}

% --- BẮT ĐẦU TÀI LIỆU ---
\begin{document}

% --- BẮT ĐẦU TRANG BÌA MỚI ---
\begin{titlepage}
    \centering
    \pagestyle{empty} % <-- Đảm bảo trang này không có header/footer
    
    % 1. Thông tin trường
    {\Large \textbf{Hanoi University of Science and Technology}} \\
    \vspace{0.2cm}
    {\large School of Information and Communication Technology} \\
    
    \vspace{1.5cm}
    
    % 2. Logo
    \includegraphics[width=0.3\textwidth]{images/logo_hust.png} \\
    
    \vspace{1.5cm}
    
    % 3. Tiêu đề chính
    {\huge \textbf{Project Report: Game Tetris using STM32CubeIDE hardware and software}} \\
    \vspace{1cm}
    
    % 4. Thông tin môn học
    {\LARGE IT4210E - Embedded Systems} \\
    \vspace{0.5cm}
    
    \vfill % <-- Đẩy nội dung bên dưới xuống
    
    % 6. Thông tin nhóm
    {\Large \textbf{Group Members:}} \\
    \vspace{0.5cm}
    {\large
    Group 5 - Class: 161346\\
    Luong Ngoc Vu Long - 20235967\\
    Tran Sy Nguyen - 20235985\\
    Nguyen Vu Anh Khoa - 20235957
    } \\ 
    
    \vspace{2cm}
    
    % 7. Giảng viên
    {\Large \textbf{Lecturers:}} \\
    \vspace{0.5cm}
    {\large
    Prof. Ngô Lam Trung
    }
    
    \vfill % <-- Đẩy ngày tháng xuống dưới cùng
    
    % 8. Ngày tháng
    {\large \today}
    
\end{titlepage}

\tableofcontents
\newpage

\section{Introduction}

This project aims to replicate the classic arcade game "Tetris" on an embedded system platform. The primary goal is to demonstrate the integration of real-time operating systems (FreeRTOS), graphical user interfaces (TouchGFX), and hardware peripheral control (GPIO, Timers, Interrupts) on the STM32F429I-DISCO development board.

The system features a 240x320 pixel color display, a dedicated audio engine for background music and sound effects using PWM, and physical button controls for game interaction. The software architecture is designed using the Model-View-Presenter (MVP) pattern provided by TouchGFX, ensuring a clean separation between game logic and visual rendering.

\section{Hardware Design}

\subsection{Development Board Specifications}
The project utilizes the STM32F429I-DISCO kit, which is built around the STM32F429ZIT6 microcontroller. Key specifications utilized in this project include:
\begin{itemize}
    \item \textbf{Core:} ARM Cortex-M4 with FPU, running at 168 MHz (configured via PLL).
    \item \textbf{Flash Memory:} 2 MB (Storing code and const assets like fonts/images).
    \item \textbf{RAM:} 256 KB Internal SRAM + 64 Mbits External SDRAM (used for Frame Buffers).
    \item \textbf{Display:} 2.4" QVGA TFT LCD via LTDC interface.
\end{itemize}

\subsection{Peripheral Configuration}

The hardware configuration is generated using STM32CubeMX (inside STM32CubeIDE).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/system_configuration.png}
    \caption{STM32CubeMX System and Peripheral Initialization Overview}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/pin_configuration.png}
    \caption{STM32F429ZIT6 Pinout and GPIO Configuration}
\end{figure}

\subsubsection{Display Subsystem (LTDC \& DMA2D)}
The Liquid Crystal Display (LCD) is driven by the LTDC (LCD-TFT Display Controller) peripheral. 
\begin{itemize}
    \item \textbf{Interface:} RGB565 (16-bit color depth).
    \item \textbf{Resolution:} 240 x 320 pixels.
    \item \textbf{Memory:} Two frame buffers are allocated in the external SDRAM to support double buffering, preventing screen tearing.
    \item \textbf{DMA2D:} Chrom-Art Accelerator is enabled to handle image copying and blending efficiently, offloading the CPU.
\end{itemize}

\subsubsection{Audio Subsystem (PWM)}
Sound generation is achieved using Pulse Width Modulation (PWM) connected to a Piezo Buzzer.
\begin{itemize}
    \item \textbf{Timer:} TIM10.
    \item \textbf{Channel:} Channel 1.
    \item \textbf{Prescaler:} 167 (resulting in a 1 MHz timer clock).
    \item \textbf{Logic:} The frequency of the PWM signal controls the musical pitch (Note), and the duty cycle controls the volume.
\end{itemize}

\subsubsection{Input Controls (GPIO \& EXTI)}
The game is controlled via four external push buttons connected to GPIO pins configured as external interrupts (EXTI).

\begin{table}[h]
    \centering
    \begin{tabularx}{0.8\textwidth}{|c|X|c|c|}
        \hline
        \textbf{Function} & \textbf{Pin} & \textbf{Port} & \textbf{Mode} \\
        \hline
        Rotate Piece & Pin 12 & GPIOB & EXTI Rising/Falling \\
        \hline
        Move Right & Pin 13 & GPIOB & EXTI Rising/Falling \\
        \hline
        Soft Drop & Pin 2 & GPIOG & EXTI Rising/Falling \\
        \hline
        Move Left & Pin 3 & GPIOG & EXTI Rising/Falling \\
        \hline
    \end{tabularx}
    \caption{GPIO Pin Mapping for Game Controls}
\end{table}

\subsection{Random Number Generator (RNG)}
To ensure fair and unpredictable gameplay, the hardware Tetromino generation relies on the STM32's built-in Random Number Generator (RNG) peripheral. The peripheral requires a precise 48 MHz clock (PLL48CLK) and is configured to provide entropy for the piece spawning logic. Detailed implementation challenges regarding the clock tree configuration are discussed in Section 4.1.

\section{Software Design}

\subsection{Model-View-Presenter (MVP) Architecture}
The software architecture is centered around the Model-View-Presenter (MVP) pattern provided by the TouchGFX framework. This pattern ensures a strict separation of concerns between the visual interface, the underlying game logic, and the synchronization layer that connects them.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/mvp_architecture_diagram.png}
    \caption{TouchGFX MVP Architecture and Class Hierarchy}
\end{figure}

\begin{itemize}
    \item \textbf{View:} Responsible for the visual representation and layout.
    \item \textbf{Model:} Contains the core game state, rules, and mathematical logic.
    \item \textbf{Presenter:} Acts as the mediator, handling events from the View and updating the Model, or reflecting Model changes back to the View.
\end{itemize}

\subsection{The View: User Interface}
The View layer is implemented using C++ classes generated by TouchGFX. It focuses on rendering the graphical assets and handling the screen layout for the 240x320 portrait display.

\subsubsection{Main Menu}
Displays the "Tetris Art" logo and options to start the game. The background plays a slower, ambient menu theme.

\subsubsection{Game Screen}
The layout is optimized for the portrait screen, dividing the interface into functional zones:
\begin{itemize}
    \item Center: 10x20 Game Matrix showing active and resting Tetrominos.
    \item Left Sidebar: HOLD piece slot and Level indicator.
    \item Right Sidebar: NEXT piece preview and Score display.
\end{itemize}

\subsection{The Model: Game Logic}
The Model layer maintains the internal state of the Tetris grid and implements the rules of the game. It is independent of the GUI framework, allowing for easier testing and logic updates.

\subsubsection{Grid Representation}
The 10x20 game board is represented as a 2D array: `signed char grid[20][10]`, where each cell stores a value corresponding to a Tetromino type or remains -1 if empty.

\subsubsection{Game Loop (`tick`)}
The `tick()` function is the entry point for game updates, called every frame (60Hz). It handles gravity, collision detection via `isCollision()`, and line clearing logic.

\begin{lstlisting}[language=C++]
void Model::tick()
{
    if (isGameOver || isPaused) return;

    tickCounter++;
    if (tickCounter >= dropSpeed)
    {
        tickCounter = 0;
        step(); // Gravity drop
    }
    // ... Input queue processing ...
}
\end{lstlisting}

\subsection{The Presenter: Logic-UI Synchronization}
The Presenter layer serves as the bridge. Classes like `GameViewPresenter` listen for notifications from the Model (via `ModelListener`) and trigger updates in the View.

When the Model state changes (e.g., a piece moves), the Presenter is notified and calls the corresponding View methods to refresh the display, ensuring the visual layer stays perfectly synchronized with the logical state. 

\begin{lstlisting}[language=C++]
// Example from GameViewPresenter.cpp
void GameViewPresenter::modelStateChanged()
{
    view.updateBoard(); // Signal the View to redraw based on new Model data
}
\end{lstlisting}

\subsection{System Integration (RTOS \& Audio)}
The application logic sits atop a real-time foundation that manages hardware resources and asynchronous background tasks.

\subsubsection{FreeRTOS Task Management}
Three primary tasks ensure smooth operation:
\begin{itemize}
    \item \textbf{GUI\_Task:} Executes the TouchGFX engine and MVP logic (High Priority).
    \item \textbf{DefaultTask:} Handles button debouncing and system monitoring.
    \item \textbf{SoundTask:} Processes audio requests in the background (Low Priority).
\end{itemize}

\subsubsection{Audio Engine}
To maintain performance, audio is handled via a Producer-Consumer pattern. The Game Model (Producer) sends `TrackID` requests to a queue, which are processed by the `SoundTask` (Consumer) to drive the PWM-based buzzer.

\section{System Integration \& Challenges}

\subsection{Clock Tree Configuration for RNG}
A significant challenge during hardware integration was the 48 MHz clock requirement for the RNG. The STM32F429 reaches its maximum performance at a SysClk of 180 MHz, but the Main PLL cannot generate both 180 MHz and 48 MHz simultaneously due to integer divider limitations. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{images/clock_configuration.png}
    \caption{Final Clock Configuration (168 MHz SysClk, 48 MHz PLL48CLK)}
\end{figure}

\begin{itemize}
    \item \textbf{The Issue:} At 180 MHz (VCO = 360 MHz), the PLLQ divider would need to be 7.5 to reach 48 MHz, which is not supported. Deviations from 48 MHz lead to peripheral initialization failure and "Clock Error" flags.
    \item \textbf{The Solution:} We adjusted the system clock to 168 MHz (PLLM=8, PLLN=336, PLLP=2, PLLQ=7).
    \item \textbf{VCO Calculation:} $(8\text{ MHz} / 8) \times 336 = 336\text{ MHz}$.
    \item \textbf{Resulting Clocks:} SysClk = $336\text{ MHz} / 2 = 168\text{ MHz}$; RNG Clock = $336\text{ MHz} / 7 = 48\text{ MHz}$ (Exact).
\end{itemize}

\subsection{Input Debouncing}
Directly reading GPIO pins caused erratic behavior due to mechanical switch bounce. We implemented software debouncing using FreeRTOS Timers.
\begin{itemize}
    \item When a button press interrupt occurs, a timer starts (e.g., 50ms).
    \item The input is only registered if the signal remains stable until the timer callback executes.
\end{itemize}

\section{Results and Conclusion}

\subsection{Project Outcomes}
The project successfully delivers a playable Tetris clone on the STM32F429I-DISCO.
\begin{itemize}
    \item Performance: The game runs at a stable 60 FPS.
    \item Audio: Background music plays smoothly without interrupting game logic.
    \item Gameplay: All standard Tetris rules (rotation, wall kicks, line clears, leveling) are implemented.
\end{itemize}

\subsection{Future Improvements}
\begin{itemize}
    \item Implement "Ghost Piece" visualization (indicated in design but currently simplified).
    \item Save high scores to internal Flash memory to persist after power loss.
    \item Add support for using the on-board Gyroscope (SPI5) for experimental tilt controls.
\end{itemize}

\end{document}